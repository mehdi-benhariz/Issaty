import { GeneratorMeta } from '@yeoman/types';
import type { CopyOptions } from 'mem-fs-editor';
import type { Data as TemplateData, Options as TemplateOptions } from 'ejs';
import YeomanGenerator, { type ComposeOptions, type Storage } from 'yeoman-generator';
import type Environment from 'yeoman-environment';
import SharedData from '../base/shared-data.js';
import { Logger } from '../base/support/index.js';
import type { JHipsterGeneratorOptions, JHipsterGeneratorFeatures, EditFileCallback, EditFileOptions, CascatedEditFileCallback, JHipsterOptions, ValidationResult, WriteFileOptions, JHipsterArguments, JHipsterConfigs, JHipsterCommandDefinition } from '../base/api.js';
import { CommonClientServerApplication } from '../base-application/types.js';
import NeedleApi from '../needle-api.js';
/**
 * This is the base class for a generator for every generator.
 */
export default class CoreGenerator extends YeomanGenerator<JHipsterGeneratorOptions, JHipsterGeneratorFeatures> {
    static asPriority: (priorityName: string) => string;
    static INITIALIZING: string;
    static PROMPTING: string;
    static CONFIGURING: string;
    static COMPOSING: string;
    static LOADING: string;
    static PREPARING: string;
    static POST_PREPARING: string;
    static DEFAULT: string;
    static WRITING: string;
    static POST_WRITING: string;
    static INSTALL: string;
    static POST_INSTALL: string;
    static END: string;
    useVersionPlaceholders?: boolean;
    skipChecks?: boolean;
    experimental?: boolean;
    debugEnabled?: boolean;
    jhipster7Migration?: boolean;
    relativeDir: (from: string, to: string) => string;
    relative: (from: string, to: string) => string;
    readonly sharedData: SharedData<CommonClientServerApplication>;
    readonly logger: Logger;
    jhipsterConfig: Record<string, any>;
    /**
     * @deprecated
     */
    jhipsterTemplatesFolders: string[];
    blueprintStorage?: Storage;
    /** Allow to use a specific definition at current command operations */
    generatorCommand?: JHipsterCommandDefinition;
    /**
     * @experimental
     * Additional commands to be considered
     */
    generatorsToCompose: string[];
    private _jhipsterGenerator?;
    private _needleApi?;
    env: Environment;
    log: Logger;
    _meta?: GeneratorMeta;
    constructor(args: string | string[], options: JHipsterGeneratorOptions, features: JHipsterGeneratorFeatures);
    /**
     * Override yeoman generator's usage function to fine tune --help message.
     */
    usage(): string;
    /**
     * @deprecated
     */
    get needleApi(): NeedleApi;
    /**
     * Warn or throws check failure based on current skipChecks option.
     * @param message
     */
    handleCheckFailure(message: string): void;
    /**
     * Check if the JHipster version used to generate an existing project is less than the passed version argument
     *
     * @param {string} version - A valid semver version string
     */
    isJhipsterVersionLessThan(version: any): boolean;
    /**
     * Get arguments for the priority
     */
    getArgsForPriority(priorityName: string): {
        control: import("../base/types.js").Control;
        source: any;
    }[] | {
        control: import("../base/types.js").Control;
        configChanges: {
            [k: string]: {
                newValue: any;
                oldValue: any;
            };
        };
    }[] | {
        control: import("../base/types.js").Control;
    }[];
    /**
     * Override yeoman-generator method that gets methods to be queued, filtering the result.
     */
    getTaskNames(): string[];
    /**
     * Get the current Command Definition for the generator.
     * `generatorCommand` takes precedence.
     */
    getCurrentJHipsterCommand(): Promise<JHipsterCommandDefinition>;
    /**
     * Parse command definition arguments, options and configs.
     * Blueprints with command override takes precedence.
     */
    parseCurrentJHipsterCommand(): Promise<void>;
    /**
     * Prompts for command definition configs.
     * Blueprints with command override takes precedence.
     */
    promptCurrentJHipsterCommand(): Promise<any>;
    /**
     * Load the current JHipster command storage configuration into the context.
     * Blueprints with command override takes precedence.
     */
    loadCurrentJHipsterCommandConfig(context: any): Promise<void>;
    /**
     * @experimental
     * Compose the current JHipster command compose.
     * Blueprints commands compose without generators will be composed.
     */
    composeCurrentJHipsterCommand(): Promise<void>;
    parseJHipsterCommand(commandDef: JHipsterCommandDefinition): void;
    parseJHipsterOptions(options: JHipsterOptions | undefined, configs?: JHipsterConfigs | boolean, common?: boolean): void;
    parseJHipsterArguments(jhipsterArguments?: JHipsterArguments): void;
    prepareQuestions(configs?: JHipsterConfigs): {
        storage: any;
        type?: "input" | "list" | "checkbox" | "confirm" | undefined;
        message?: string | ((any: any) => string) | undefined;
        when?: boolean | ((any: any) => boolean) | undefined;
        default?: any;
        filter?: any;
        transformer?: any;
        validate?: any;
        name: string;
        choices: import("../base/api.js").JHispterChoices | undefined;
    }[];
    /**
     * Generate a date to be used by Liquibase changelogs.
     *
     * @param {Boolean} [reproducible=true] - Set true if the changelog date can be reproducible.
     *                                 Set false to create a changelog date incrementing the last one.
     * @return {String} Changelog date.
     */
    dateFormatForLiquibase(reproducible?: boolean): string;
    /**
     * Alternative templatePath that fetches from the blueprinted generator, instead of the blueprint.
     */
    jhipsterTemplatePath(...path: string[]): string;
    /**
     * Compose with a jhipster generator using default jhipster config.
     * @return {object} the composed generator
     */
    composeWithJHipster(generator: string, options?: ComposeOptions): Promise<import("@yeoman/types").BaseGenerator[]>;
    /**
     * Compose with a jhipster generator using default jhipster config, but queue it immediately.
     */
    dependsOnJHipster(generator: string, options?: ComposeOptions): Promise<import("@yeoman/types").BaseGenerator[]>;
    /**
     * Remove File
     * @param file
     */
    removeFile(...path: string[]): string;
    /**
     * Remove Folder
     * @param path
     */
    removeFolder(...path: string[]): void;
    /**
     * Fetch files from the generator-jhipster instance installed
     */
    fetchFromInstalledJHipster(...path: string[]): string;
    /**
     * Utility function to write file.
     *
     * @param source
     * @param destination - destination
     * @param data - template data
     * @param options - options passed to ejs render
     * @param copyOptions
     */
    writeFile(source: string, destination: string, data?: TemplateData, options?: TemplateOptions, copyOptions?: CopyOptions): void;
    /**
     * write the given files using provided options.
     */
    writeFiles<DataType = any>(options: WriteFileOptions<this, DataType>): Promise<string[]>;
    /**
     * Edit file content.
     * Edits an empty file if `options.create` is truthy or no callback is passed.
     * @example
     * // Throws if `foo.txt` doesn't exists or append the content.
     * editFile('foo.txt', content => content + 'foo.txt content');
     * @example
     * // Appends `foo.txt` content if whether exists or not.
     * editFile('foo.txt', { create: true }, content => content + 'foo.txt content');
     * @example
     * // Appends `foo.txt` content if whether exists or not using the returned cascaded callback.
     * editFile('foo.txt')(content => content + 'foo.txt content');
     */
    editFile(file: string, ...transformCallbacks: EditFileCallback<this>[]): CascatedEditFileCallback<this>;
    editFile(file: string, options: EditFileOptions, ...transformCallbacks: EditFileCallback<this>[]): CascatedEditFileCallback<this>;
    /**
     * Convert value to a yaml and write to destination
     */
    writeDestinationYaml(filepath: string, value: Record<string | number, any>): void;
    /**
     * Merge value to an existing yaml and write to destination
     * Removes every comment (due to parsing/merging process) except the at the top of the file.
     */
    mergeDestinationYaml(filepath: string, value: Record<string | number, any>): void;
    /**
     * Merge value to an existing json and write to destination
     */
    mergeDestinationJson(filepath: string, value: Record<string | number, any>): void;
    /**
     * Shallow clone or convert dependencies to placeholder if needed.
     */
    prepareDependencies(map: Record<string, string>, valuePlaceholder?: 'java' | 'docker' | ((value: string) => string)): Record<string, string>;
    loadNodeDependencies(destination: Record<string, string>, source: Record<string, string>): void;
    /**
     * Load Java dependencies from a gradle catalog file.
     * @param javaDependencies
     * @param gradleCatalog Gradle catalog file path, true for generator-jhipster's generator catalog of falsy for blueprint catalog
     */
    loadJavaDependenciesFromGradleCatalog(javaDependencies: Record<string, string>, gradleCatalog?: string | boolean): void;
    loadNodeDependenciesFromPackageJson(destination: Record<string, string>, packageJsonFile?: string): void;
    /**
     * Print ValidationResult info/warnings or throw result Error.
     */
    validateResult(result: ValidationResult, { throwOnError }?: {
        throwOnError?: boolean | undefined;
    }): void;
    /**
     * Checks if there is a newer JHipster version available.
     */
    protected checkForNewVersion(): Promise<void>;
    /**
     * Create a simple-git instance using current destinationPath as baseDir.
     */
    createGit(): import("simple-git").SimpleGit;
    private calculateApplicationId;
    protected getSharedApplication(applicationFolder?: string): any;
    private createSharedData;
}
